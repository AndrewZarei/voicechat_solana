<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéôÔ∏è Voice Chat dApp Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .control-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #f0f0f0;
            border-radius: 15px;
            background: #fafafa;
        }
        
        .control-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            color: #1976d2;
        }
        
        .status.success {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            color: #2e7d32;
        }
        
        .status.error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
        }
        
        .status.warning {
            background: #fff8e1;
            border-left: 4px solid #ff9800;
            color: #ef6c00;
        }
        
        .pda-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .pda-box {
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
        }
        
        .pda-box.active {
            border-color: #4caf50;
            background: #f8fff9;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2);
        }
        
        .pda-box.used {
            border-color: #2196f3;
            background: #f3f8ff;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.2);
        }
        
        .pda-title {
            font-weight: bold;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 8px;
        }
        
        .pda-size {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        
        .pda-status {
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
        }
        
        .pda-status.ready {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .pda-status.used {
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .pda-status.empty {
            background: #f5f5f5;
            color: #666;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .info-card h4 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .info-label {
            color: #666;
            font-weight: 500;
        }
        
        .info-value {
            color: #333;
            font-weight: 600;
        }
        
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 8px;
            color: #c62828;
            margin: 10px 0;
        }
        
        .recording-indicator.active {
            display: flex;
        }
        
        .pulse {
            width: 12px;
            height: 12px;
            background: #f44336;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéôÔ∏è Voice Chat dApp</h1>
            <p>Decentralized Voice Communication on Solana</p>
        </div>
        
        <div class="main-content">
            <!-- System Initialization -->
            <div class="control-section">
                <h3>üöÄ System Initialization</h3>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="initializeVoiceChatSystem()">
                        üîß Initialize Voice Chat System
                    </button>
                    <button class="btn btn-info" onclick="createStoragePDAs()">
                        üì¶ Create Storage PDAs (10√ó30KB)
                    </button>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="initProgress"></div>
                </div>
            </div>
            
            <!-- Voice Room Management -->
            <div class="control-section">
                <h3>üè† Voice Room Management</h3>
                <div class="button-group">
                    <button class="btn btn-success" onclick="createVoiceRoom()">
                        üè† Create Voice Room
                    </button>
                    <button class="btn btn-info" onclick="joinRoom()">
                        üë• Join Room
                    </button>
                    <button class="btn btn-warning" onclick="leaveRoom()">
                        üö™ Leave Room
                    </button>
                </div>
            </div>
            
            <!-- Voice Communication -->
            <div class="control-section">
                <h3>üé§ Voice Communication</h3>
                <div class="button-group">
                    <button class="btn btn-success" onclick="startRecording()" id="recordBtn">
                        üé§ Start Recording
                    </button>
                    <button class="btn btn-warning" onclick="stopRecording()" id="stopBtn" disabled>
                        ‚èπÔ∏è Stop Recording
                    </button>
                    <button class="btn btn-primary" onclick="sendVoiceData()" id="sendBtn" disabled>
                        üì§ Send Voice Data
                    </button>
                    <button class="btn btn-info" onclick="receiveVoiceData()">
                        üì• Receive Voice Data
                    </button>
                    <button class="btn btn-success" onclick="playRecordedVoice()" id="playBtn" disabled>
                        üîä Play Last Recording
                    </button>
                    <button class="btn btn-warning" onclick="playSentVoice()" id="playSentBtn" disabled>
                        üéµ Play Sent Voice
                    </button>
                </div>
                
                <div class="recording-indicator" id="recordingIndicator">
                    <div class="pulse"></div>
                    <span>Recording in progress... <span id="recordingTime">0:00</span></span>
                </div>
                
                <!-- Audio playback controls -->
                <div style="margin-top: 15px;">
                    <audio id="audioPlayer" controls style="width: 100%; display: none;">
                        Your browser does not support the audio element.
                    </audio>
                </div>
            </div>
            
            <!-- Status Display -->
            <div id="status" class="status info">
                Voice Chat dApp initialized. Click "Initialize Voice Chat System" to begin.
            </div>
            
            <!-- Information Panels -->
            <div class="info-panel">
                <div class="info-card">
                    <h4>üìä System Status</h4>
                    <div class="info-item">
                        <span class="info-label">Storage PDAs:</span>
                        <span class="info-value" id="pdaCount">0/10</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Total Storage:</span>
                        <span class="info-value" id="totalStorage">0KB</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">System Status:</span>
                        <span class="info-value" id="systemStatus">Not Initialized</span>
                    </div>
                </div>
                
                <div class="info-card">
                    <h4>üè† Room Information</h4>
                    <div class="info-item">
                        <span class="info-label">Room ID:</span>
                        <span class="info-value" id="roomId">Not Created</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Participants:</span>
                        <span class="info-value" id="participantCount">0</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Room Status:</span>
                        <span class="info-value" id="roomStatus">Inactive</span>
                    </div>
                </div>
                
                <div class="info-card">
                    <h4>üé§ Voice Data</h4>
                    <div class="info-item">
                        <span class="info-label">Recording:</span>
                        <span class="info-value" id="recordingStatus">Stopped</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Data Size:</span>
                        <span class="info-value" id="voiceDataSize">0KB</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Last Sent:</span>
                        <span class="info-value" id="lastSent">Never</span>
                    </div>
                </div>
            </div>
            
            <!-- Storage PDAs Grid -->
            <div class="control-section">
                <h3>üì¶ Storage PDAs Status (10√ó30KB)</h3>
                <div class="pda-grid" id="pdaGrid">
                    <!-- PDA status boxes will be generated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let isRecording = false;
        let voiceData = [];
        let currentRoom = null;
        let storagePDAs = [];
        let recordingStartTime = null;
        let recordingTimer = null;
        let systemInitialized = false;
        
        // Audio recording variables
        let mediaRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        let recordedAudioBlob = null;
        let sentAudioData = []; // Store sent audio for playback
        
        // Initialize the demo
        function initializeDemo() {
            console.log("üéØ Initializing Voice Chat Demo...");
            
            // Create PDA grid
            const grid = document.getElementById('pdaGrid');
            for (let i = 0; i < 10; i++) {
                const pdaBox = document.createElement('div');
                pdaBox.className = 'pda-box';
                pdaBox.id = `pda-${i}`;
                pdaBox.innerHTML = `
                    <div class="pda-title">Storage PDA ${i}</div>
                    <div class="pda-size">30KB Capacity</div>
                    <div class="pda-status empty">Not Created</div>
                `;
                grid.appendChild(pdaBox);
            }
            
            updateStatus('Voice Chat dApp loaded. Initialize the system to begin.', 'info');
        }
        
        // Main system initialization (simulates the complete flow)
        async function initializeVoiceChatSystem() {
            updateStatus('üöÄ Initializing Voice Chat System...', 'info');
            updateProgress(0);
            
            try {
                // Step 1: Create storage PDAs
                updateProgress(20);
                await createStoragePDAs();
                
                // Step 2: Initialize voice room system
                updateProgress(60);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 3: Complete initialization
                updateProgress(100);
                systemInitialized = true;
                
                updateSystemStatus('Initialized');
                updateStatus('‚úÖ Voice Chat System initialized successfully! All 10 storage PDAs created (300KB total).', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå System initialization failed: ${error.message}`, 'error');
                updateProgress(0);
            }
        }
        
        // Create storage PDAs
        async function createStoragePDAs() {
            updateStatus('üì¶ Creating 10 storage PDAs with 30KB each...', 'info');
            
            storagePDAs = [];
            
            for (let i = 0; i < 10; i++) {
                // Simulate PDA creation
                await new Promise(resolve => setTimeout(resolve, 200));
                
                const pdaBox = document.getElementById(`pda-${i}`);
                pdaBox.classList.add('active');
                pdaBox.querySelector('.pda-status').textContent = 'Ready';
                pdaBox.querySelector('.pda-status').className = 'pda-status ready';
                
                storagePDAs.push({
                    index: i,
                    address: `PDA${i}_${Math.random().toString(36).substr(2, 8)}`,
                    capacity: 30720, // 30KB
                    used: 0,
                    status: 'ready'
                });
                
                // Update progress
                const progress = ((i + 1) / 10) * 80; // 80% of total progress
                updateProgress(progress);
                
                console.log(`‚úÖ Created storage PDA ${i}`);
            }
            
            updatePDACount(storagePDAs.length);
            updateTotalStorage(storagePDAs.length * 30);
            
            updateStatus('‚úÖ All 10 storage PDAs created successfully! Total: 300KB storage available.', 'success');
        }
        
        // Create voice room
        async function createVoiceRoom() {
            if (!systemInitialized) {
                updateStatus('‚ùå Please initialize the system first.', 'error');
                return;
            }
            
            const roomId = `voice-room-${Date.now()}`;
            updateStatus(`üè† Creating voice room: ${roomId}...`, 'info');
            
            try {
                // Simulate room creation
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                currentRoom = {
                    id: roomId,
                    participants: 1,
                    status: 'Active',
                    host: 'You',
                    created: new Date().toISOString()
                };
                
                updateRoomInfo(roomId, 1, 'Active');
                updateStatus(`‚úÖ Voice room '${roomId}' created successfully! You are the host.`, 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Error creating voice room: ${error.message}`, 'error');
            }
        }
        
        // Join room
        async function joinRoom() {
            if (!currentRoom) {
                updateStatus('‚ùå No active room to join. Create a room first.', 'error');
                return;
            }
            
            try {
                await new Promise(resolve => setTimeout(resolve, 500));
                
                currentRoom.participants++;
                updateRoomInfo(currentRoom.id, currentRoom.participants, currentRoom.status);
                
                updateStatus(`‚úÖ Joined voice room '${currentRoom.id}'. Participants: ${currentRoom.participants}`, 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Error joining room: ${error.message}`, 'error');
            }
        }
        
        // Leave room
        async function leaveRoom() {
            if (!currentRoom) {
                updateStatus('‚ùå No active room to leave.', 'error');
                return;
            }
            
            try {
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (currentRoom.participants > 1) {
                    currentRoom.participants--;
                    updateRoomInfo(currentRoom.id, currentRoom.participants, currentRoom.status);
                    updateStatus(`‚úÖ Left voice room '${currentRoom.id}'. Participants: ${currentRoom.participants}`, 'success');
                } else {
                    // Last participant - close room
                    const roomId = currentRoom.id;
                    currentRoom = null;
                    updateRoomInfo('Not Created', 0, 'Inactive');
                    updateStatus(`‚úÖ Left and closed voice room '${roomId}'.`, 'success');
                }
                
            } catch (error) {
                updateStatus(`‚ùå Error leaving room: ${error.message}`, 'error');
            }
        }
        
        // Start recording
        async function startRecording() {
            if (!currentRoom) {
                updateStatus('‚ùå Join a voice room first before recording.', 'error');
                return;
            }
            
            if (isRecording) {
                updateStatus('‚ùå Already recording.', 'error');
                return;
            }
            
            try {
                // Request microphone access
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    } 
                });
                
                // Create MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                    
                    // Convert to array buffer for blockchain storage simulation
                    recordedAudioBlob.arrayBuffer().then(buffer => {
                        voiceData = new Uint8Array(buffer);
                        updateVoiceDataSize(Math.floor(voiceData.length / 1024)); // Show in KB
                        
                        // Enable play button
                        document.getElementById('playBtn').disabled = false;
                        document.getElementById('sendBtn').disabled = false;
                    });
                };
                
                // Start recording
                mediaRecorder.start(100); // Collect data every 100ms
                isRecording = true;
                recordingStartTime = Date.now();
                
                // Update UI
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('recordingIndicator').classList.add('active');
                updateRecordingStatus('Recording');
                
                // Start recording timer
                recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('recordingTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 100);
                
                updateStatus('üé§ Started recording voice... Speak into your microphone!', 'info');
                
            } catch (error) {
                updateStatus(`‚ùå Error accessing microphone: ${error.message}. Please allow microphone access.`, 'error');
                console.error('Microphone access error:', error);
            }
        }
        
        // Stop recording
        function stopRecording() {
            if (!isRecording) {
                updateStatus('‚ùå Not currently recording.', 'error');
                return;
            }
            
            // Stop media recorder
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Stop audio stream
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
            }
            
            isRecording = false;
            clearInterval(recordingTimer);
            
            // Update UI
            document.getElementById('recordBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('recordingIndicator').classList.remove('active');
            updateRecordingStatus('Stopped');
            
            const duration = Math.floor((Date.now() - recordingStartTime) / 1000);
            updateStatus(`‚èπÔ∏è Recording stopped. Processing audio data... (${duration} seconds recorded)`, 'success');
        }
        
        // Send voice data
        async function sendVoiceData() {
            if (!currentRoom) {
                updateStatus('‚ùå No active room. Create/join a room first.', 'error');
                return;
            }
            
            if (!recordedAudioBlob) {
                updateStatus('‚ùå No voice data to send. Record some audio first.', 'error');
                return;
            }
            
            try {
                // Select target PDA (round-robin or based on data size)
                const targetPDA = Math.floor(Math.random() * storagePDAs.length);
                const dataSize = Math.floor(voiceData.length / 1024); // Convert to KB
                
                updateStatus(`üì§ Sending ${dataSize}KB voice data to Storage PDA ${targetPDA}...`, 'info');
                
                // Store the audio data for later playback
                sentAudioData.push({
                    audioBlob: recordedAudioBlob,
                    timestamp: new Date().toISOString(),
                    targetPDA: targetPDA,
                    size: dataSize
                });
                
                // Simulate sending data to blockchain
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Update PDA status
                if (storagePDAs[targetPDA]) {
                    storagePDAs[targetPDA].used += dataSize;
                    storagePDAs[targetPDA].status = 'used';
                    
                    const pdaBox = document.getElementById(`pda-${targetPDA}`);
                    pdaBox.classList.remove('active');
                    pdaBox.classList.add('used');
                    pdaBox.querySelector('.pda-status').textContent = `Used (${dataSize}KB/30KB)`;
                    pdaBox.querySelector('.pda-status').className = 'pda-status used';
                }
                
                // Update UI
                document.getElementById('sendBtn').disabled = true;
                document.getElementById('playSentBtn').disabled = false; // Enable play sent voice
                updateLastSent(new Date().toLocaleTimeString());
                
                updateStatus(`‚úÖ Voice data sent successfully to Storage PDA ${targetPDA}! You can now play it back.`, 'success');
                
                // Reset recording state but keep audio for playback
                document.getElementById('playBtn').disabled = true;
                updateVoiceDataSize(0);
                
            } catch (error) {
                updateStatus(`‚ùå Error sending voice data: ${error.message}`, 'error');
            }
        }
        
        // Play recorded voice (before sending)
        function playRecordedVoice() {
            if (!recordedAudioBlob) {
                updateStatus('‚ùå No recorded audio to play. Record something first.', 'error');
                return;
            }
            
            try {
                const audioPlayer = document.getElementById('audioPlayer');
                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                
                audioPlayer.src = audioUrl;
                audioPlayer.style.display = 'block';
                audioPlayer.play();
                
                updateStatus('üîä Playing your recorded voice...', 'info');
                
                audioPlayer.onended = () => {
                    updateStatus('‚úÖ Playback finished.', 'success');
                    URL.revokeObjectURL(audioUrl);
                };
                
            } catch (error) {
                updateStatus(`‚ùå Error playing audio: ${error.message}`, 'error');
            }
        }
        
        // Play sent voice (retrieved from blockchain simulation)
        function playSentVoice() {
            if (sentAudioData.length === 0) {
                updateStatus('‚ùå No sent voice data to play. Send some voice data first.', 'error');
                return;
            }
            
            try {
                // Play the most recent sent audio
                const latestAudio = sentAudioData[sentAudioData.length - 1];
                const audioPlayer = document.getElementById('audioPlayer');
                const audioUrl = URL.createObjectURL(latestAudio.audioBlob);
                
                audioPlayer.src = audioUrl;
                audioPlayer.style.display = 'block';
                audioPlayer.play();
                
                updateStatus(`üéµ Playing voice data from Storage PDA ${latestAudio.targetPDA} (sent at ${new Date(latestAudio.timestamp).toLocaleTimeString()})...`, 'info');
                
                audioPlayer.onended = () => {
                    updateStatus('‚úÖ Sent voice playback finished. This simulates retrieving and playing voice from Solana blockchain!', 'success');
                    URL.revokeObjectURL(audioUrl);
                };
                
            } catch (error) {
                updateStatus(`‚ùå Error playing sent audio: ${error.message}`, 'error');
            }
        }
        
        // Receive voice data
        async function receiveVoiceData() {
            if (!currentRoom) {
                updateStatus('‚ùå No active room. Join a room first.', 'error');
                return;
            }
            
            try {
                updateStatus('üì• Retrieving voice data from storage PDAs...', 'info');
                
                // Simulate retrieving data
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const usedPDAs = storagePDAs.filter(pda => pda.used > 0);
                
                if (usedPDAs.length === 0) {
                    updateStatus('üì≠ No voice data found in storage PDAs.', 'warning');
                    return;
                }
                
                let totalData = 0;
                usedPDAs.forEach(pda => totalData += pda.used);
                
                // If we have sent audio data, enable playback
                if (sentAudioData.length > 0) {
                    document.getElementById('playSentBtn').disabled = false;
                    updateStatus(`‚úÖ Retrieved ${totalData}KB of voice data from ${usedPDAs.length} storage PDAs. Click "Play Sent Voice" to hear it!`, 'success');
                } else {
                    updateStatus(`‚úÖ Retrieved ${totalData}KB of voice data from ${usedPDAs.length} storage PDAs. Ready for playback.`, 'success');
                }
                
            } catch (error) {
                updateStatus(`‚ùå Error receiving voice data: ${error.message}`, 'error');
            }
        }
        
        // Utility functions
        function updateStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateProgress(percent) {
            document.getElementById('initProgress').style.width = `${percent}%`;
        }
        
        function updatePDACount(count) {
            document.getElementById('pdaCount').textContent = `${count}/10`;
        }
        
        function updateTotalStorage(kb) {
            document.getElementById('totalStorage').textContent = `${kb}KB`;
        }
        
        function updateSystemStatus(status) {
            document.getElementById('systemStatus').textContent = status;
        }
        
        function updateRoomInfo(roomId, participants, status) {
            document.getElementById('roomId').textContent = roomId;
            document.getElementById('participantCount').textContent = participants;
            document.getElementById('roomStatus').textContent = status;
        }
        
        function updateRecordingStatus(status) {
            document.getElementById('recordingStatus').textContent = status;
        }
        
        function updateVoiceDataSize(kb) {
            document.getElementById('voiceDataSize').textContent = `${kb}KB`;
        }
        
        function updateLastSent(time) {
            document.getElementById('lastSent').textContent = time;
        }
        
        // Initialize demo on page load
        document.addEventListener('DOMContentLoaded', initializeDemo);
        
        // Console instructions
        console.log(`
üéôÔ∏è VOICE CHAT DAPP DEMO LOADED WITH REAL AUDIO!

üìã Instructions:
1. Click "Initialize Voice Chat System" to create 10√ó30KB storage PDAs
2. Click "Create Voice Room" to start a voice chat session
3. Click "Start Recording" to capture REAL voice from your microphone
4. Click "Stop Recording" when finished speaking
5. Click "Play Last Recording" to hear what you recorded
6. Click "Send Voice Data" to store on Solana blockchain
7. Click "Play Sent Voice" to hear the voice retrieved from blockchain!

üé§ Audio Features:
- ‚úÖ Real microphone recording (WebRTC MediaRecorder API)
- ‚úÖ High-quality audio capture (44.1kHz, Opus codec)
- ‚úÖ Play recorded voice before sending
- ‚úÖ Play sent voice after blockchain storage
- ‚úÖ Simulates complete voice chat flow with real audio

üîß Integration Notes:
- This demo uses REAL audio recording and playback
- Microphone permission required for recording
- Audio data is stored as binary blobs (ready for blockchain)
- In production, replace simulation with actual Anchor program calls
- Connect to Phantom/Solflare wallet for real transactions

üéØ Smart Contracts:
- Storage Manager: Creates 10 PDAs √ó 30KB each (300KB total)
- Voice Chat Manager: Handles voice data transmission
- Program IDs: SU6CRGJXz5ksvXPyUuWXYfW2qmba6ZgHa3sxdr9aYMz, GVqX9pcoxbiY7i1W3Ad6Sinw1pNpwUHq1tu4tpkH6TF8

üéµ Try it now: Record your voice and hear it played back from the "blockchain"!
        `);
    </script>
</body>
</html>
